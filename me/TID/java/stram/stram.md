# 스트림(stream)

---

## 스트림이란?

---

* 스트림은 데이터 소스를 추상화 하고, 데이터를 다루는데 자주 사용되는 메서드
  들을 정의해 놓은것 이다.
* 데이터 추상화란, 데이터소스가 무엇이던 간에 같은 방식으로 다룰 수 있게
  되었다는 것과 코드의 재사용성이 높아진다는 것을 의미한다.
* ~~~
  String[] strArr = {"aaa","bbb","ccc"}
  List<String>  strList = Arrays.asList(strArr);

* 스트림으로 변환 ->
* ~~~ 
  Stream<String> strStream1 = strList.stream();
  Stream<String> strStream2 = Arrays.stream(strArr);
* 컬렉션과 배열의 스트림 생성 방법은 다르다.
* 하지만 스트림으로 만들어진 데이터 소스의 데이터를 읽어서 정렬하고 출력하는
  방법은 같다.(데이터소스가 정렬되는 것이 아니다.)
* 스트림은 데이터 소스를 변경하지 않는다.
    * 데이터 소스로 부터 데이터를 읽기만 할 뿐, 데이터 소스를 변경하지 않는다.
    * 변경이 필요하다면, 정렬된 결과를 컬렉션이나 배열에 담아 반환 가능하다.
* 스트림은 일회용이다.
    * 한번 사용하면 닫혀서 다시 사용 할 수 없다.
    * 필요하다면 스트림을 다시 생성해야 한다.
* 스트림은 작업을 내부 반복으로 처리한다.
    * 내부반복은 반복문을 메서드 내부에 숨길 수 있다는 것을 의미한다.
* 스트림의 연산
    * 스트림이 제공하는 다양한 연산을 이용해서 복잡한 작업들을 간단히 처리할 수 있다.
    * 스트림이 제공하는 연산은 중간 연산과 최종연산으로 분류할 수 있다.
    * 중간 연산은 연산 결과를 스트림으로 반환하기 때문에 중간 연산을 연속해서 연결 할 수 있다.
    * 최종연산은 스트림의 요소를 소모하면서 연산을 수행하므로 단 한번만 연산이 가능하다.
    * 중간 연산
        * 연산 결과가 스트림인 연산. 스트림에 연속해서 중간 연산할 수 있음
    * 최종 연산
        * 연산 결과가 스트림이 아닌 연산. 스트림의 요소를 소모하므로 단 한번만 가능
* 지연된 연산
    * 스트림 연산에서 중요한 점은 최종 연산이 수행되기 전까지는 중간 연산이 수행되지 않는다는 것이다.
    * 최종 연산이 수행되어야 비로소 스트림의 요소들이 중간 연산을 거쳐 최종 연산에서 소모된다.
* Stream<Integer>와 IntStream
    * 언박싱의 비효율을 줄이기 위해 데이터 소스의 요소를 기본형 으로 다루는 스트림이 제공된다.
    * 일반적으로는 Stream<Integer> 보다 IntStream이 더 효율적이다.
* 병렬 스트림
    * 스트림으로 데이터를 다룰 때의 장점 중 하나는 병렬 처리가 쉽다는 것이다.
    * 병렬 스트림은 내부적으로 fork&join 프레임웍을 이용해서 자동적으로 연산을 병렬로 처리한다.
    * 사용자는 parallel()이라는 메서드를 호출해서 지시하면 될 뿐이다.
    * 병렬 처리가 항상 더 빠른 결과를 얻게 해주는 것이 아니라는걸 잊지 말자.

## 스트림 만들기

---

* 스트림의 소스가 될 수 있는 대상은 배열, 컬렉션, 임의의 수 등 다양하다.
* 컬렉션
  * 컬렉션의 최고 조상인 Collection에 stream()이 정의되어 있다.
  * 자손인 List와 Set을 구현한 컬레션 클래스들은 모두 이 메서드로 스트림을 
  생성할 수 있다.
* 배열
  * 배열을 소스로 하는 스트림을 생성하는 메서드는 Stream과 Arrays에 정의되어 있다.
  * int, long, double과 같은 기본형 배열을 소스로 하는 스트림을 생성하는 메서드도 있다.
* 임의의 수
  * 난수를 생성하는데 사용하는 Random클래스에는 해당 타입의 난수들로 이루어진
  스트림을 반환한다.
  * 이 스트림은 크기가 정해지지 않은 '무한 스트림'이므로 스트림의 크기를 제한하는 메서드를
  사용해서 크기를 제한해 주어야 한다.
  * 매개변수로 스트림의 크기를 지정해서 '유한 스트림'을 생성해서 반환하는경우는 
  크기를 제한하는 메서드를 사용할 필요가 없다.
* 람다식 - iterate(), generate()
  * 람다식을 매개변수로 받아서, 이 람다식에 의해 계산괴는 값들을 요소로 하는 
  무한 스트림을 생성한다.
  * ~~~
    static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
    static <T> Stream<T> generate(Supplier<T> s)
  * iterate()는 씨앗값으로 지정된 값부터 시작해서 람다식에 의해 계산된 결과를
  다시 seed값으로 해서 계산을 반복한다.
  * generate()는 이전 결과를 이용해서 다음 요소를 계산하지 않는다.
  * generate()에 정의된 매개변수 타입은 Suppier<T> 이므로 매개변수가 없는 람다식만 허용된다.
* 빈 스트림
  * 요소가 하나도 없는 비어있는 스트림을 생성할 수도 있다.
  * 스트림에 연산을 수행한 결과가 하나도 없을 때, null보다 빈 스트림을 반환해 주는게 좋다.
* 두 스트림의 연결
  * concat()을 사용하면, 두 스트림을 하나로 연결할 수 있다.
  * 연결하려는 두 스트림의 요소는 같아야 한다.

## 스트림의 중간연산

---
* 스트림 자르기 - skip(),limit()
  * 스트림의 일부를 잘라낼 때 사용한다.
  * skip(n) - n개의 요소를 건너 뛴다.
  * limit(n) - 스트림의 요소를 n개로 제한한다.
* 스트림의 요소 걸러내기 - filter(), distinct()
  * distinct() - 중복되는 요소를 제거한다.
  * filter() - 주어진 조건에 맞지않는 요소를 걸러낸다.
    * Predicate를 매개변수로 필요로 하지만 연산 결과가 boolean인
    람다식을 사용해도 된다.
    * filter()를 다른 조건으로 여러번 사용할 수 있다.
* 정렬 - sorted()
  * 지정된 Comparator로 스트림을 정렬한다.
  * int값을 반환하는 람다식을 사용하는 것도 가능하다.
  * Comparator를 지정하지 않으면 스트림 요소의 기본 정렬 기준으로 정렬한다.
  * 스트림의 요소가 Comparable을 구현한 클래스가 아니면 예외가 발생한다.
* 변환 - map()
  * 원하는 필드만 뽑아내거나 특정 형태로 변환해야 할 때 사용하는 것이다.
  * 매개변수로 T타입을 R타입으로 변환해서 반환하는 함수를 지정해야 한다.
  * 하나의 스트림에 여러번 적용할 수 있다.
* 조회 - peek()
  * 연산과 연산 사이에 올바르게 처리되었는지 확인할 수 있다.
  * 스트림의 요소를 소모히자 않으므로 연산 사이에 여러번 끼워도 문제가 되지 않는다.
  * 