# 스프링 DI

---

## 1 의존이란?

---
* DI는 'Dependency Injection'의 약자로 우리말로는 '의존 주입'이라고
번역한다.
* 의존은 객체 간의 의존을 의미한다.
* 한 클래스가 다른 클래스의 메서드를 실행할 때 이를 '의존'한다고 표현한다.
* 변경에 따른 영향이 전파되는 관계를 '의존'란다고 표현한다.
* 의존 대상을 구하는 가장 쉬운 방법은 의존 대상 객체를 직접 생성하는 것이다.
* 클래스 내부에서 직접 의존 객체를 생성하는 것이 쉽긴 하지만 유지보수 관점
에서는 문제를 유발할 수 있다.
* 객체 직접 생성이 아닌 DI와 서비스 로케이터 방법도 있다.

## 2 DI를 통한 의존 처리

---
* DI는 의존하는 객체를 직접 생성하는 대신 의존 객체를 전달받는 방식을 사용한다.
* DI를 적용한 결과 클래스를 사용하는 코드는 객체를 생성할 때 생성자에 객체를
전달해야 한다.
* 그냥 직접 의존객체를 생성하면 되는데 굳이 생성자를 통해서 의존하는 객체를
주입하는 걸까?
* 변경의 유연함 때문이다.

## 3. DI와 의존 객체 변경의 유연함

---
* 의존 객체를 직접 생성하는 방식은 필드나 생성자에 new 연산자를 이용해서
객체를 생성한다.
* 만약 생성한 클래스를 변경해야한다면 사용한 모든곳에서 변경해야 한다.
* DI를 사용하면 수정할 코드가 줄어든다.

## 4. 객체 조립기

---
* 실제 객체를 생성하는 코드는 어디에 있을까?
* 메인 메서드에서 의존 대상 객체를 생성하고 주입하는 방법이 나쁘진 않다.
* 이 방법보다 나은 방법은 객체를 생성하고 의존 객체를 주입해주는 클래스를
따로 작성하는 것이다.
* 의존 객체를 주입하는 것은 서로 다른 두 객체를 조립한다고 생각할 수 있는데,
이런 의미에서 이 클래스를 조립기 라고도 표현한다.


## 6. 스프링의 DI 설정

---
* 스프링은 DI를 지원하는 조립기이다.
* 스프링은 범용 조립기이다.

### 6.1 스프링을 이용한 객체 조립과 사용

---
* @Configuration 애노테이션은 스프링 설정 클래스를 의미한다. 이 애노테이션을 붙여야
스프링 설정 클래스로 사용할 수 있다.
* @Bean 애노테이션은 해당 메서드가 생성한 객체를 스프링 빈으로 설정한다.
* 메서드를 이용해서 생성한 빈 객체는 메서드이름으로 스프링에 등록된다.
* 설정 클래스를 만들고 의존 객체를 주입하는건 설정 컨테이너이므로 설정 클래스를 이용해서
컨테이너를 생성해야 한다.

### 6.2 DI 방식 1: 생성자 방식

---
* 생성자를 통해 의존 객체를 주입받아 필드에 할당할 수 있다.
  * 생성자를 통해 의존 객체를 주입받음
  * 주입 받은 객체를 필드에 할당
  * 주입 받은 의존 객체의 메서드를 사용

### 6.3 DI 방식 2: 세터 메서드 방식

---
* 생성자 외에 세터 메서드를 이용해서 객체를 주입받기도 한다.
* 일반적인 세터 메서드는 자바빈 규칙에 따라 다음과 같이 작성한다.
  * 메서드 이름이 set으로 시작한다.
  * set뒤에 첫 글자는 대문자로 시작한다.
  * 파라미터가 1개이다.
  * 리턴 타입이 void 이다.
* 자바빈에서는 게터와 세터를 이용해서 프로퍼티를 정의한다.


* 생성자 방식 vs 세터 메서드 방식
  * 생성자 방식
    * 빈 객체를 생성하는 시점에 모든 의존 객체가 주입된다.
  * 설정 메서드 방식
    * 세터 메서드 이름을 통해 어떤 의존 객체가 주입되는지 알 수 있다.

### 6.4 기본 데이터 타입 값 설정

---
* 빈 객체가 가지고 있는 변수가 기본 데이터 타입일 경우 일반 코드처럼 값을 설정하면 된다.

## 7 @Configuration 설정 클래스의 @Bean 설정과 싱글톤

---
* 스프링 컨테이너는 @Bean이 붙은 메서드에 대해 한개의 객체만 생성한다.
* 다른 설정 메서드에서 몇번을 호출하더라도 항상 같은 객체를 리턴한다.
* 스프링 런타임에 생성한 설정 클래스의 메서드는 매번 새로운 객체를 생성하지 않는다.
* 한 번 생성한 객체를 보관했다가 이후에는 동일한 객체를 리턴한다.

## 8 두 개 이상의 설정 파일 사용하기

---
* 스프링을 이용해서 어플리케이션을 개발하다 보면 수백여개 이상의 빈을 설정하게 된다.
* 설정하는 빈의 개수가 증가하면 한 개의 클래스 파일에 설정하는 것보다 영역별로 설정
파일을 나누면 관리하기 편해진다.
* 스프링은 한 개 이상의 설정 파일을 이용해서 컨테이너를 생성할 수 있다.
* 설정 클래스가 두 개 이상이어도 스프링 컨테이너를 생성하는 코드는 크게 다르지 않다.


### 8.1 @Configuration 애노테이션, 빈, @Autowired 애노테이션

---
* @Autowired 애노테이션은 스프링 빈에 의존하는 다른 빈을 자동으로 주입하고 싶을 때 사용한다.
* @Autowired 애노테이션을 의존 주입 대상에 붙이면 스프링 설정 클래스의 @Bean 메서드에서
의존 주입을 위한 코드는 작성하지 않아도 된다.
* ```
  @Bean
  접근제어자 타입 메서드(){
  세터 메서드를 사용해서 의존 주입을 하지 않아도
  스프링 컨테이너가 @Autowired를 붙인 필드에
  자동으로 해당 타입의 빈 객체를 주입
  }
  ```
* 스프링 컨테이너는 설정 클래스에서 사용한 @Autowired에 대해서도 자동 주입을 처리한다.
* 실제로 스프링은 @Configuration 애노테이션이 붙은 설정 클래스를 내부적으로 스프링
빈으로 등록한다.
* 그리고 다른 빈과 마찬가지고 @Autowired가 붙은 대상에 대해 알맞은 빈을 자동으로 주입한다.

### 8.2 @Import 애노테이션 사용

---
* 두개 이상의 설정 파일을 사용하는 또 다른 방법은 @Import 애노테이션을 사용하는 것이다.

## 9 getBean() 메서드 사용

---
* getBean(빈의이름,빈의타입)

## 10 주입 대상 객체를 모두 빈 객체로 설정해야 하나?

---
* 주입할 객체가 꼭 스프링 빈이어야 할 필요는 없다.