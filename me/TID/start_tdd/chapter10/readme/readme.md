# 테스트 코드와 유지보수

---

## 테스트 코드와 유지보수

* TDD를 하는 과정에서 작성한 테스트 코드는 CI/CD에서 자동화 테스트로 사용되어 버그가
  배포되는것을 막아주고 이는 소프트웨어 품질이 저하되는 것을 방지한다.
* 테스트 코드는 그 자체로도 코드이기 때문에 제품 코드와 동일하게 유지보수 대상이 된다.
* 테스트 코드를 유지보수하는 데 시간이 많이 들기 시작하면 점점 테스트 코드를 손보지 않아
  실패하는 테스트가 증가하게 된다.
* 깨지는 테스트를 방치하는 상황이 길어지면 다음과 같은 문제가 발생할 수 있다.
    * 실패한 테스트가 새로 발생해도 무감각해진다. 테스트 실패 여부에 상관없이 빌드 하고
      배포하기 시작한다.
    * 빌드를 통과시키기 위해 실패한 테스트를 주석 처리하고 실패한 테스트는 고치지 않는다.
* 이런 상황이 발생하면 테스트 코드는 가치를 잃기 시작한다.
* 테스트 코드는 코드를 변경했을 때 기존 기능이 올바르게 동작하는지 확인하는 회귀 테스트를
  자동화하는 수단으로 사용되는데 깨진 테스트를 방치하기 시작하면 회귀 테스트가 검증하는 범위가
  줄어든다.
* 소프트웨어의 품질이 낮아질 가능성이 커진다.
* 테스트 코드가 줄어들면 수동으로 테스트 하는 범위가 증가한다.
* 수동 테스트는 자동화된 테스트에 비해 오랜 시간이 걸리고 다룰 수 있는 범위도 제한되므로
  기존 코드에 문제가 있어도 놓칠 가능성이 커지게 된다.
* 테스트 코드를 유지보수하기 좋아야 지속적으로 테스트를 작성하게 되고 결과적으로 소프트웨어의
  품질이 떨어지는 것도 막을 수 있다.

## 변수나 필드를 사용해서 기댓값 표현하지 않기

* 가독성이 매우 떨어질 수 있으므로 실제 값을 사용하자.

## 두 개 이상을 검증하지 ㅇ낳기

* 처음 테스트 코드를 작성하면 한 테스트 메서드에 가능한 많은 단언을 하려고 시도한다.
* 그 과정에서 서로 다른 검증을 섞는 경우가 있다.
* 한 테스트에서 검증하는 내용이 2 개 이상이면 테스트 결과를 확인할 때 집중도가 떨어진다.
* 만약 첫 번째 검증이 실패하면 테스트는 거기서 멈춘다.
* 첫 번째 검증 대상을 통과 시켜야 비로소 두 번째 검증이 성공했는지 여부를 확인할 수 있다.
* 또한, 테스트에 실패 했을 때 두 가지 검증 대상 중 무엇이 실패했는지 확인해야 한다.
* 한 테스트가 한 가지만 검증하면 테스트에 실패 했을 때 무엇이 잘못되었는지 빨리 알 수 있고
  검증 대상이 한정되어 있으므로 테스트도 빨리 통과시킬 수 있다.

## 정확하게 일치하는 값으로 모의 객체 설정하지 않기

* 모의 객체는 가능한 범용적인 값을 사용해서 기술해야 한다.
* 한정된 값에 일치하도록 모의 개게를 사용하면 약간의 코드 수정만으로도 테스트는 실패하게 된다.
* 이 경우 테스트 코드의 일부 값을 수정하면 모의 객체 관련 코드도 함께 수정하는 번거로움이 있다.
* 범용적인 값을 사용하자

## 과도하게 구현 검증하지 않기

* 테스트 코드를 작성할 때 주의할 점은 테스트 대상의 내부 구현을 검증하는 것이다.
* 내부 구현을 검증하는 것이 나쁜 것은 아니지만 한 가지 단점이 있다. 그것은 바로 구현을
  조금만 변경해도 테스트가 깨질 가능성이 커진다는 것이다.
* 내부 구현은 언제든지 바뀔 수 있기 때문에 테스트 코드는 내부 구현보다 실행 결과를 검증해야 한다.
* 기능이 정상적으로 동작하는지 확인할 수단이 구현 검증밖에 없다면 모의 객체를 사용해서
  테스트 코드를 작성해야 하지만 일단 테스트 코드를 작성한 뒤에는 점진적으로 코드를 리팩토링 해서
  구현이 아닌 결과를 검증할 수 있도록 시도해야 한다.

## 셋업을 이용해서 중복된 상황을 설정하지 않기

* 테스트 코드를 작성하다 보면 각 테스트 코드에서 동일한 상황이 필요할 때가 있다.
* 이 경우 중복된 코드를 제거하기 위해 @BeforeEach 메서드를 이용해서 상황을 구현할 수 있다.
* 하지만 셋업 메서드의 구조가 바뀌면 테스트가 깨질 수도 있다.
* 셋업 메서드를 이용해서 여러 메서드에 동일한 상황을 적용하는 것이 처음에는 편리하지만,
  시간이 지나면 테스트 코드를 이해하고 유지 보수하는데 오히려 방해 요소가 된다.
* 테스트 메서드는 자체적으로 검증하는 내용을 완전히 기술하고 있어야 테스트 코드를 유지보수하는
  노력을 줄일 수 있다.

## 통합 테스트에서 데이터 공유 주의하기

* @Sql 애노테이션으로 지정한 sql 파일은 다음과 테스트에 필요한 데이터를 초기화한다.
* 통합 테스트 메서드는 데이터 초기화를 위한 코드를 작성하지 않아도 된다.
* 통합 테스트 코드를 만들 때는 다음의 두가지고 초기화 데이터를 나눠서 생각해야 한다.
    * 모든 테스트가 같은 값을 사용하는 데이터
    * 테스트 메서드에서만 필요한 데이터

## 통합 테스트의 상황 설정을 위한 보조 클래스 사용하기

* 테스트 메서드에서 직접 상황을 구성하면서 코드 중복을 없애는 방법이 있는데 그것은 바로
  상황 설정을 위한 보조 클래스를 사용하는 것이다.
* 검증을 위해 데이터를 조회하는 코드가 여러 테스트 메서드에 중복되어 있으면 유지보수에
  좋지 않다. 이럴 때는 상황 설정과 동일하게 결과 검증을 위한 보조 클래스를 마들어 테스트
  코드를 유지보수하기 좋은 코드로 만들 수 있다.

## 실행 환경이 다르다고 실패하지 않기

* 같은 테스트 메서드가 실행 환경에 따라 성공하거나 실패하면 안된다.

## 실행 시점이 다르다고 실패하지 않기

* 시간값을 제어해서 테스트 시점을 제어하자.

## 랜덤하게 실패하지 않기

* 랜덤값에 따라 달라지는 결과를 검증할 때 주로 문제가 발생한다.
* 랜덤하게 생성한 값이 결과 검증에 영향을준다면 구조를 변경해야 테스트가 가능하다.
* 직접 랜덤값을 생성하지 말고 생성자를 통해 값을 받고록 수정하면 테스트가 가능해진다.

## 필요하지 않은 값을 설정하지 않기

* 테스트에 필요한 값만 설정하면 필요하지 않은 값을 설정하느라 고민할 필요가 없다.
* 테스트 코드가 짧아져서 한눈에 내용을 파악할 수 있다.

## 조건부로 검증하지 않기

* 테스트는 성공하거나 실패해야 한다.
* 만약 조건에 따라서 단언을 하지 않으면 그 테스트는 성공하지도 실패하지도 않는 테스트가 된다.

## 더이상 쓸모 없는 테스트 코드

* 특정 클래스의 사용법을 익히기 위해 작성한 테스트 코드는 오래 유지할 필요가 없으므로 삭제한다.
* 테스트 커버리지를 높이기 위한 목적으로 작성한 테스트 코드도 유지할 필요가 없다.
* 테스트 커버리지를 높여야 한다면 실제로 테스트 코드가 다루지 않는 if-else나 하위
타입 등을 찾아 테스트를 추가해야 한다.

### 테스트 커버리지
* 테스트하는 동안 실행하는 코드가 얼마나 되는지 설명하기 위해 사용하는 지표로 비율으 사용한다.
* 한 메서드의 길이가 10줄인데 테스트 하는 동안 8줄의 코드를 실행한다면 이때 커버리지는 80%가 된다.


