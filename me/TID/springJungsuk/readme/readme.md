# 원격 프로그램의 실행

---
## 원격 프로그램 실행

---
* 브라우저와 WAS가 있어야 원격 프로그램 실행 가능
* 프로그램 등록
  * 외부에서 어떤 프로그램을 사용할지 등록
  * @Controller 애노테이션을 사용
* URL과 프로그램을 연결
  * RequestMapping을 사용 메서드와 연결
* URL로 원격 프로그램을 호출하면 톰캣이 객체를 생성해주고 메서드를 실행 시킨다.
* 왜 인스턴스 메서드로 하는가?
  * 변수 사용
* 접근 제한자가 private여도 사용이 가능한가?
  * RequestMapping은 접근 제어자 상관 없이 호출 가능하다.
  * 내부에서는 private 으로 다른 객체가 접근 할 수 없다.
  * Reflection API 를 사용해서 정보를 얻어서 다룰 수 있기 때문에 가능하다.

## HTTP 요청과 응답

---
* URL로 요청이 오면 Tomcat이 HttpServletRequest객체를 만들어서 요청 정보를 담는아서
메서드에 넘겨준다
* 쿼리스트링 = 값을 전달할 때 사용 URL은 문자열이다.
* 쿼리스트링 값은 name = value 형태로 존재한다.
* 동적 리소스
  * 사용자의 요청에 따라 매번 바뀌는 리소스
* 정적 리소스
  * 사용자의 요청에도 변하지 않는 리소스
* 프로토콜이란? HTTP
  * 서로간의 통신을 위한 약속, 규칙
  * 주고 받을 데이터에 대한 형식을 정의한 것
  * 단순하고 읽기 쉽다. - 텍스트 기반의 프로토콜
  * 상태를 정보를 유지하지 않는다.
    * stateless
  * 확장 가능하다. - 커스텀 헤더 추가 가능
* GET
  * 서버의 리소스를 가져오기 위해 설계
  * QUERY STRING을 통해 데이터를 전달
  * URL에 데이터 노출되므로 보안에 취약
  * 데이터 공유에 유리
* POST
  * 서버에 데이터를 올리기 위해 설계됨
  * 전송 데이터 크기의 제한이 없음(대용량)
  * 데이터를 요청 메시지의 body에 담아 전송
  * 보안에 유리, 데이터 공유에는 불리

### 텍스트 파일 vs, 바이너리 파일

---
* 바이너리 파일 : 문자와 숫자가 저장되어 있는 파일
  * 데이터를 있는 그대로 읽고 쓴다.
* 텍스트 파일 : 문자만 있는 저장되어 있는 파일
  * 숫자를 문자로 변환 후 쓴다.

### MIME


---
* 텍스트 기반 프로토콜에 바이너리 데이터 전송하기 위해 고안된 HTTP의 COntent-Type
* 헤더에 사용. 데이터의 타입을 명시

### 클라이언트와 서버

---
* 클라이언트 
  * 서비스를 요청하는 애플리케이션
* 서버
  * 서비스를 제공하는 애플리케이션
* WAS
  * 웹 애플리케이션 서버 : 웹 애플리케이션을 서비스하는 서버

## 관심사의 분리, MVC 패턴 - 이론

---
### 관심사의 분리

---
* 단일 책임 원칙
  * 하나의 메서드는 하나의 책임만 진다.

### 공통 코드의 분리 

---
* request로 매개변수를 받아와서 들어온걸 getParameter로 꺼내 쓴다.
* 클라이언트의 요청 타입을 매개변수로 받을 때 자동 형변환도 해준다.(변경 가능할 경우)
* Model을 매개변수로 설정하면 DispatcherServlet 이 생성해서 넣어준다.
* 컨트롤러에서 직접 만드려면 ModelAndView를 사용한다(잘 안씀)
* 반환타입이 String인 경유 뷰 이름 반환 한다.
* 반환타입이 void인 경우 매핑된 URL 끝단어가 뷰 이름으로 지정된다.
* 반환타입이 ModelAndView인 경우 Model과 뷰 이름을 반환한다.

## 서블릿과 JSP

---
### 서블릿의 생명 주기

---
* Servlet은 HttpServlet을 상속 받아야 한다.
* init() 서블릿이 초기화될 때 자동 호출되는 메서드
  * 서블릿의 초기화 작업 담당
* service() 실제로 작업을 처리하는 메서드
  * 입력 -> 처리 -> 출력
* destroy() 서블릿이 메모리에서 제거 될 때
  * 서블릿 컨테이너에 의해서 제거된다.
* 요청 -> 서블릿인스턴스 존재? 
* no -> 서블릿 클래스 로딩 & 인스턴스 생성 -> init() -> service() 
* yes-> service() 
* 서블릿은 싱글톤이다. 1개의 인스턴스로 재활용 한다.

### JSP와 서블릿 비교

---
* JSP란? HTML 안에 자바 코드가 있는 파일.
* 확장자가 *.jsp인 경우 jspServlet이 받는다.
* JSP파일이 변경되면 다시 변환하고 컴파일 후 객체로 만드는 과정을 실행한다.
* 처음부터 객체를 만들어 두는게 아닌 요청이 들어왔을 때 만든다.
* 서블릿 = lazy-init 지연된 초기화
* 스프링 = early-init 미리 초기화
* JSP는 생성없이 사용할 수 있는 기본 객체가 있다.
  * service()의 지역번수 request, response, session, application, config, out, page 등등
* 4개 저장소가 있다.
  * pageContext
    * 유효 범위 : 1개 JSP 페이지
    * 설명 : JSP 페이지의 시작부터 끝까지. 해당 JSP 내부에서만 접근가능. 페이지당 1개
  * application
    * 유효 범위 : context 전체
    * 설명 : WevApplication의 시작부터 종료까지. context내부 어디에서나 접근 가능
    모든 클라이언트가 공유. context마다 1개
  * session
    * 유효 범위 : n개 JSP 페이지
    * 설명 : session의 시작부터 종료까지(로그인~로그아웃). 클라이언트마다 1개
  * request
    * 유효 범위 : 1+개 JSP 페이지
    * 설명 : 요청의 시작부터 응답까지. 다른 JSP로 전달 가능. 요청마다 1개
* 속성 관련 메서드
  * void setAttribute(String name, Object value) : 지정된 값(value)을 지정된 
  속성 이름(name)으로 저장
  * Object getAttribute(String name) : 지정된 이름(name)으로 저장된 속성의 값 반환